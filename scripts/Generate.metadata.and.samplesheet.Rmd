---
title: "Create Illumina Sample Sheet and metadata"
author: "Ramon Gallego"
date: "11/8/2019"
output: html_document
params: 
  Assay: 
    value: "Nextera XT"
    input: select
    choices: [Nextera XT, UDI]
  Index_Adapters:
    value:  "Nextera XT Index Kit (96 Indexes 384 Samples)"
    input: select
    choices: [Nextera XT Index Kit (96 Indexes 384 Samples),
    UDI 386 Samples]
  Match_with_well:
    value:  "Yes"
    label: "Using default Well"
    choices: [Yes, No]
    input: select  
  Cycles_per_pairend: 301
  Set: 1
  input.metadata: 
    value: ../data_sub/metadata.csv
    input: file
  date: !r Sys.Date()
  output_dir: ../data_sub/

---
## How to use this

To run this Rmarkdown, open it in Rstudio and from the knit drop-down menu, choose Knit with parameters
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library (tidyverse)
library (here)
library (kableExtra)

```

## What does this do

It creates the Illumina Sample sheet and the `metadata.csv` file that you need for running the pipeline. You need to double check the output - weird things happen all the time.

## Required input

You need an input file with at least the following columns:

  - Sample_name: Avoid spaces - for compatibility with MiSeq's sample sheet, use hyphen "-" instead of underscores "_" or full stops "."
  - Well:  in the 96-well plate used for the Nextera reaction. If you are using UDI indices, and select the option `Matching with well`,  then this field MUST match that of the UDI plate you are using.
  - Set: Use A,B,C,D or 1,2,3,4. Crucial for the UDI plate
  - PrimerF: using IUPAC wildcard character
  - PrimerR: ditto
  - Locus: Name of the locus, again without spaces.
  - i7_Index_Name: Adapter used to identify samples. Format is N7XX for the Nextera. 
  - i5_Index_Name: Adapter used to identify samples. Format is N5XX for the Nextera.
  - UDI_Index_Name: Adapter used to identify samples with the UDI. Format is  UDPXXXX

## Load the Illumina adapters

```{r load nextera}

Nextera_Adapters_i7 <- read_csv(here("data_sub","Nextera_adapters_i7.csv"))

Nextera_Adapters_i5 <- read_csv(here("data_sub","Nextera_adapters_i5.csv")) 

UDI_Nextera <- read_csv(here("data_sub", "Dual_indices_Adapters.csv"))
```

## Loading the metadata you want to sequence

```{r load metadata}

init.metadata <- read_csv(params$input.metadata)

init.metadata

```

### Check that the metadata has all needed fields

```{r Check metadata, echo=F, include=T}

 reqs <-  c("Sample_name", 
        "Well",
        "PrimerF",
        "PrimerR",
        "Locus")


        

if(params$Assay == "UDI" & params$Match_with_well == TRUE){
  reqs <- c(reqs,        "Set") } else {
    
if(params$Assay == "UDI" & params$Match_with_well == FALSE) { 
       reqs <- c(reqs,
        "Set",
        "UDI_Index_Name") } else{
if(params$Assay != "UDI"){
      
      reqs <- c(reqs,
                "i5_Index_Name",
                "i7_Index_Name")
      
    }
    }
}
  if (sum(reqs %in% colnames(init.metadata)) < length(reqs)  ){
    message <- cat(paste(reqs, collapse = '\n'))
    knitr::knit_exit(append = paste0(" ERROR: Initial metadata is missing some of the key column names:
                                     ",
                                     paste(reqs, collapse = '\n'),
                                     "
                                     Change the column names / add the infromation to your csv file",
                                     sep = '\n' ))
  }
  

```
The i5 and i7 indices can start by  either N, S, or H. But the sequence is the same. Let's make sure that they are compatible with the Nextera Indices file


# Adding Indices and Sequences

If using Nextera - Find the Index you used and adding the sequences for the SampleSheet.

```{r Nexter1}
if(params$Assay != "UDI"){
  
  # indices are sometimes denoted as NXXX or SXXX - But the numbvers are all the same - change to NXXX
init.metadata %>% 
  mutate(i5_Index_Name = str_replace(i5_Index_Name, "^[EHNS]", "N"),
         i7_Index_Name = str_replace(i7_Index_Name, "^[HN]", "N")) -> init.metadata
  # Check that all samples provided have a sequence
  case_when(nrow(anti_join(init.metadata, Nextera_Adapters_i5)) + nrow(anti_join(init.metadata, Nextera_Adapters_i7)) == 0 ~ "All indices present in the  dataset",
           # == 0 ~ "Pass i7",
          TRUE                                                     ~ "Either some of the i5 or the i7 indices are not present in the Nextera Indices list - That will result in NAs in the final Sample Sheet")
  # Merge
  init.metadata %>% 
  left_join(Nextera_Adapters_i7) %>% 
  left_join(Nextera_Adapters_i5) -> metadata
  
  }

```

Make the check that all the indices are present

If using UDIs, two options: If you used the default position of the UDIs on their plates, then use the fields `Well` and `Set` to do the matching. Check that the Sets are in the same format in both datasets

```{r UDI Match}
if(params$Assay == "UDI" & params$Match_with_well == TRUE){
  test <- summary(unique(init.metadata$Set) %in% 1:4)
test
  
   if (is.na(test["FALSE"]) ) {
  left_join(init.metadata, UDI_Nextera, by = c("Well", "Set")) -> metadata
    } else{

    # Sets are also known as ABCD
    print("Set values are not 1,2,3,4")
    print("Assuming this is what you meant - Check if not")

    kable(tibble(Metadata.Set = init.metadata$Set,
                 UDI.Set      = as.numeric(as.factor(init.metadata$Set))) %>%
            distinct())

    init.metadata %>%
      mutate(Set = as.numeric(as.factor(Set))) -> init.metadata

    # Check if well had a 0 in front of number for cols 1-9 (A1 or A01)

    if(sum(str_detect(init.metadata$Well, pattern = "[A-Z]0")) > 0){

      print("Found some 0s in the Wells before column 10 - fixing that (Changing A01 to A1). Check if unsure")

    init.metadata %>%
      separate(Well, into = c("Row", "Column"), sep = 1, convert = T) %>%
      unite(Row, Column, col = "Well", sep = "") -> init.metadata
    }


    left_join(init.metadata, UDI_Nextera, by = c("Well", "Set")) -> metadata

    }


}

# If you provided the UDIs identifiers, then do an easier joint

if(params$Assay == "UDI" & params$Match_with_well == FALSE){

   case_when(nrow(anti_join(init.metadata, UDI_Nextera, by = "UDI_Index_Name"))  == 0 ~ "All indices present in the  dataset",
          TRUE                                                     ~ "Either some of the i5 or the i7 indices are not present in the Nextera Indices list - That will result in NAs in the final Sample Sheet")

  left_join(init.metadata, UDI_Nextera %>% select(-Set),by = "UDI_Index_Name" ) -> metadata


}
```


## Load the Illumina SampleSheet template



```{r Loading SampleSheet}

template.sample.sheet <- read_lines(here("data_sub","SampleSheet.csv"))

```

Locate all the lines in which the new parameters are going to be written

```{r locate terms}


date.row  <- str_which(template.sample.sheet, "^\\Date")
Assay.row <- str_which(template.sample.sheet, "^Assay")
Index.row <- str_which(template.sample.sheet, "^Index Adapters")
Reads.row <- str_which(template.sample.sheet, "^\\[Reads]")
data.start <- str_which(template.sample.sheet, "^\\[Data]")
data.header <- str_which(template.sample.sheet, "^Sample_ID")

```




## Fill Illumina SampleSheet

In the case where there are many loci represented on each sample, usually you have them in the same well. If this is the case, your Illumina samplesheet will have fewer entries (rows) than your metadata sheet. In the Illumina sampleSheet, there are two parts: one that refers to the whole plate, and one that specificies the samples run.

### Parameters that refer to the whole sequencing run

These include date of analysis,

```{r}
template.sample.sheet[date.row] <- paste0("Date,",params$date)

template.sample.sheet[Assay.row] <- paste0("Assay," ,params$Assay)
template.sample.sheet[Index.row] <- paste0("Index Adapters,",params$Index_Adapters)
template.sample.sheet[Reads.row +1 ] <- template.sample.sheet[Reads.row + 2] <- params$Cycles_per_pairend
```

Then with the rest of the dataset - collapsing first by primers

```{r collapse by primer}

metadata %>%
  group_by( Bases_for_Sample_Sheet_i5,Bases_for_Sample_Sheet_i7 ) %>%
  tally() -> occurrence.of.combos

if(max(occurrence.of.combos$n) > 1 ){
  print("There are combinations of barcodes assigned to more than 1 sample - Please Check they have different PCR primers so you can separate them after")
  metadata %>%
  group_by(Bases_for_Sample_Sheet_i5,Bases_for_Sample_Sheet_i7 ) %>%
    slice(1) -> metadata.for.sample.sheet
  print ("Keeping the first occurence of each combo for your samplesheet")}else{metadata.for.sample.sheet <- metadata}
```

Now write the SampleSheet to a file
```{r, echo = T}

Sets <- params$Set

if(params$Assay == "UDI"){
   metadata.for.sample.sheet$i7_Index_Name <- metadata.for.sample.sheet$UDI_Index_Name
   metadata.for.sample.sheet$i5_Index_Name <- metadata.for.sample.sheet$UDI_Index_Name
   Sets <- metadata.for.sample.sheet$Set
}

sample.data <- tibble (Sample_ID   = metadata.for.sample.sheet$Sample_name,
                      Sample_Plate = Sets,
                      Sample_Well  = metadata.for.sample.sheet$Well,
                      I7_Index_ID  = metadata.for.sample.sheet$i7_Index_Name,
                      index        = metadata.for.sample.sheet$Bases_for_Sample_Sheet_i7,
                      I5_Index_ID  = metadata.for.sample.sheet$i5_Index_Name,
                      index2       = metadata.for.sample.sheet$Bases_for_Sample_Sheet_i5,
                      Sample_Project = "",
                      Description = "")


nsamples <- nrow(sample.data)
template.sample.sheet <- template.sample.sheet[1:data.header]
for (i in 1:nsamples){

  template.sample.sheet[i+data.header] <- paste(sample.data[i,], collapse = ",")

  }


write_lines(template.sample.sheet,
            file.path(params$output_dir,paste0( "SampleSheet_",Sys.Date(),".csv")),
            sep = "\r\n")


```

## Fill in metadata


We are going to assume that the Illumina always returns files with the format `Sample_name` `Sample_number` `_L001_R` [1-2] '_001.fastq`. So let's fill the metadata accordingly.

### Step1 Get the filenames

```{r}

sample.data %>%
  mutate(Sample_name = str_replace_all(Sample_ID,pattern = "[\\.|_]",replacement = "-")) %>%
  rownames_to_column("Sample_number") %>%
  mutate(file1 = paste0(Sample_name, "_S", Sample_number, "_L001_R1_001.fastq"),
         file2 = paste0(Sample_name, "_S", Sample_number, "_L001_R2_001.fastq")) %>%
  select(i7_Index_Name = I7_Index_ID, i5_Index_Name = I5_Index_ID, file1, file2) -> filenames
```


```{r, echo=F}

if(params$Assay == "UDI"){
   metadata$i7_Index_Name <- metadata$UDI_Index_Name
   metadata$i5_Index_Name <- metadata$UDI_Index_Name
}

metadata %>%
  left_join(filenames, by = c("i7_Index_Name","i5_Index_Name" )) %>%
  select(Sample_name,
         file1,
         file2,
         i7_Index_Name,
         i5_Index_Name,
         Well,
         PrimerF,
         PrimerR,
         Locus) -> metadata

```

### Check that primer sequences do not include non-IUPAC characters

```{r NON-IUPAC characters}
IUAPAC.char <- read_csv(here("data_sub","IUAPAC.csv"))

IUPAC.char.1 <- paste(IUAPAC.char$Nucleotide.symbol, collapse = "")
IUPAC.char.1 <- paste0("[^",IUPAC.char.1,"]")

allprimers = paste0(metadata$PrimerR, metadata$PrimerF, collapse = "")

case_when(str_count(allprimers, IUPAC.char.1) > 0 ~ print("There are non-IUAPAC characters in your primers, changing them to N"))

metadata %>%
  mutate_at(.vars = vars(starts_with("Primer")), function(x)str_replace_all(x, IUPAC.char.1, "N")) -> metadata

```


```{r}

write_csv(metadata, file.path(params$output_dir,paste0( "metadata_",Sys.Date(),".csv")))

kable(metadata, align= "c", format = "html") %>%
      kable_styling(bootstrap_options= "striped", fixed_thead = T,full_width = T, position = "center") %>%
      column_spec(2, bold=T) %>%
  scroll_box(width = "1200px", height = "600px")

```

